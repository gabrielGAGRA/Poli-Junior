' Força a declaração de todas as variáveis. Essencial para evitar erros de digitação.
Option Explicit

' =========================================================================================
' MACRO PRINCIPAL - Orquestra todo o processo de atualização.
' =========================================================================================
Sub AtualizarForecastCompleto()
    Dim wsInfos As Worksheet
    Dim wsFcst As Worksheet
    Dim mapa As Object ' Usaremos um Dicionário para o mapeamento
    
    ' --- 1. CONFIGURAÇÃO ---
    On Error Resume Next
    Set wsInfos = ThisWorkbook.Worksheets("infos")
    Set wsFcst = ThisWorkbook.Worksheets("forecast")
    On Error GoTo 0
    
    If wsInfos Is Nothing Or wsFcst Is Nothing Then
        MsgBox "Planilhas 'infos' e/ou 'forecast' não encontradas. Verifique os nomes.", vbCritical
        Exit Sub
    End If
    
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    
    ' Cria o dicionário de mapeamento
    Set mapa = CriarMapaDePara()
    
    ' --- 2. EXECUÇÃO ---
    ' Primeiro, preenche os dados que vêm diretamente da 'infos'
    Call PreencherDadosDiretos(wsInfos, wsFcst, mapa)
    
    ' Depois, calcula os totais, TMs e outros indicadores na 'forecast'
    Call CalcularAgregadosETMs(wsFcst)
    
    ' --- 3. FINALIZAÇÃO ---
    Application.Calculation = xlCalculationAutomatic
    Application.ScreenUpdating = True
    
    MsgBox "Forecast atualizado com sucesso!", vbInformation
End Sub

' =========================================================================================
' FUNÇÃO AUXILIAR - Cria e retorna um dicionário com o mapeamento.
' Chave: Nome da categoria na 'infos'. Valor: Texto da linha na 'forecast'.
' Manter este mapeamento em um lugar centralizado facilita futuras manutenções.
' =========================================================================================
Private Function CriarMapaDePara() As Object
    Set CriarMapaDePara = CreateObject("Scripting.Dictionary")
    
    ' Mapeamento Bloco 1.A - EXPORTAÇÃO
    CriarMapaDePara.Add "expo_leve_mes", "Receita leve (R$ mil)"
    CriarMapaDePara.Add "expo_pesado_mes", "Receita pesado (R$ mil)"
    CriarMapaDePara.Add "expo_leve_veic", "# Veículos leve (unid)"
    CriarMapaDePara.Add "expo_pesado_veic", "# Veículos pesado (unid)"
    
    ' Mapeamento Bloco 1.B - IMPORTAÇÃO
    CriarMapaDePara.Add "import_leve_mes", "Receita leve (R$ mil)"
    CriarMapaDePara.Add "import_pesado_mes", "Receita pesado (R$ mil)"
    CriarMapaDePara.Add "import_leve_veic", "# Veículos leve (unid)"
    CriarMapaDePara.Add "import_pesado_veic", "# Veículos pesado (unid)"
    
    ' Mapeamento Bloco 2 - CARGA SOLTA
    CriarMapaDePara.Add "carga_solta_mes", "Receita (R$ mil)"
    CriarMapaDePara.Add "carga_solta_veic", "Quantidade Carga solta" ' Assumindo este mapeamento
    
    ' Mapeamento Bloco 3 - Outros (Assumindo divisão, ajuste se necessário)
    CriarMapaDePara.Add "outros_mes", "Receita Demais serviços (R$ mil)" ' Exemplo, pode ser Inspeção
    CriarMapaDePara.Add "outros_veic", "TM (R$/veíc.) - contribuição Demais serviços" ' Verificar essa lógica
    
    ' Mapeamento Bloco 4 - Operação de Cais
    CriarMapaDePara.Add "oper_cais_mes", "Receita Operação de Cais (R$ mil)"
    
    ' Mapeamento Bloco 5 - Carga Geral
    CriarMapaDePara.Add "carga_geral_mes", "Receita Carga Geral (R$ mil)"

End Function

' =========================================================================================
' SUB-ROTINA - Preenche os valores diretos da 'infos' na 'forecast'.
' =========================================================================================
Private Sub PreencherDadosDiretos(ByVal wsInfos As Worksheet, ByVal wsFcst As Worksheet, ByVal mapa As Object)
    Dim lastColInfos As Long, lastRowInfos As Long
    Dim colInfos As Long, linInfos As Long
    Dim colFcst As Long
    Dim dataColuna As Date, ano As Integer, mes As Integer
    Dim categoriaInfos As String, valor As Double, descricaoFcst As String
    Dim rngDestino As Range, findRange As Range
    
    ' Define o range de busca na coluna B da forecast
    Set findRange = wsFcst.Columns("B")
    
    lastColInfos = wsInfos.Cells(1, wsInfos.Columns.Count).End(xlToLeft).Column
    lastRowInfos = wsInfos.Cells(wsInfos.Rows.Count, "A").End(xlUp).Row
    
    ' Loop através de cada coluna de data na 'infos' (a partir da coluna B)
    For colInfos = 2 To lastColInfos
        dataColuna = wsInfos.Cells(1, colInfos).Value
        ano = Year(dataColuna)
        mes = Month(dataColuna)
        
        ' Encontra a coluna correspondente na 'forecast'
        colFcst = EncontrarColunaFcst(wsFcst, ano, mes)
        
        If colFcst > 0 Then ' Se encontrou a data correspondente...
            ' Loop através de cada categoria na 'infos'
            For linInfos = 2 To lastRowInfos
                categoriaInfos = wsInfos.Cells(linInfos, "A").Value
                
                If mapa.Exists(categoriaInfos) Then
                    descricaoFcst = mapa(categoriaInfos)
                    valor = wsInfos.Cells(linInfos, colInfos).Value
                    
                    ' Encontra a linha na 'forecast' com base na descrição
                    Set rngDestino = findRange.Find(What:=descricaoFcst, LookIn:=xlValues, LookAt:=xlWhole, MatchCase:=False)
                    
                    If Not rngDestino Is Nothing Then
                        wsFcst.Cells(rngDestino.Row, colFcst).Value = valor
                    End If
                End If
            Next linInfos
        End If
    Next colInfos
End Sub

' =========================================================================================
' SUB-ROTINA - Calcula os valores agregados, TMs e outros na 'forecast'.
' =========================================================================================
Private Sub CalcularAgregadosETMs(ByVal wsFcst As Worksheet)
    ' Lógica de cálculo (Exemplo para um bloco, deve ser replicado para os outros)
    ' A implementação completa requer encontrar dinamicamente cada linha
    ' Este é um exemplo simplificado. O código real seria mais robusto
    ' usando a função Find para cada item, para não depender de números de linha fixos.
    
    ' Futuramente, podemos refatorar isso para ser totalmente dinâmico.
    ' Por enquanto, o foco é mostrar a lógica.
    
    MsgBox "A rotina de cálculo dos agregados e TMs precisa ser detalhada." & vbCrLf & _
           "Por exemplo, 'Receita Exportação' é a soma de 'Receita leve' e 'Receita pesado'." & vbCrLf & _
           "Esta lógica precisa ser implementada para cada linha de cálculo na 'forecast'.", vbExclamation, "Próximo Passo"
           
    ' EXEMPLO de como seria a lógica para uma coluna (ex: coluna 5, que é a 'E')
    ' Dim col As Long
    ' For col = 3 to wsFcst.Cells(1, wsFcst.Columns.Count).End(xlToLeft).Column
    '
    '    Dim rLeveR As Double, rPesadoR As Double, rLeveV As Double, rPesadoV As Double
    '
    '    rLeveR = wsFcst.Cells(FindRow(wsFcst, "Receita leve (R$ mil)"), col).Value
    '    rPesadoR = wsFcst.Cells(FindRow(wsFcst, "Receita pesado (R$ mil)"), col).Value
    '    wsFcst.Cells(FindRow(wsFcst, "Receita Exportação (R$ mil)"), col).Value = rLeveR + rPesadoR
    '
    '    rLeveV = wsFcst.Cells(FindRow(wsFcst, "# Veículos leve (unid)"), col).Value
    '    rPesadoV = wsFcst.Cells(FindRow(wsFcst, "# Veículos pesado (unid)"), col).Value
    '    wsFcst.Cells(FindRow(wsFcst, "# Veículos Exportação (unid)"), col).Value = rLeveV + rPesadoV
    '
    '    If (rLeveV + rPesadoV) > 0 Then
    '        wsFcst.Cells(FindRow(wsFcst, "TM Exportação (R$/veíc.)"), col).Value = (rLeveR + rPesadoR) / (rLeveV + rPesadoV)
    '    Else
    '        wsFcst.Cells(FindRow(wsFcst, "TM Exportação (R$/veíc.)"), col).Value = 0
    '    End If
    ' Next col
End Sub


' =========================================================================================
' FUNÇÃO AUXILIAR - Encontra a coluna na 'forecast' com base no ano e mês.
' =========================================================================================
Private Function EncontrarColunaFcst(ByVal ws As Worksheet, ByVal ano As Integer, ByVal mes As Integer) As Long
    Dim lastCol As Long, c As Long
    lastCol = ws.Cells(1, ws.Columns.Count).End(xlToLeft).Column
    EncontrarColunaFcst = 0
    
    For c = 3 To lastCol ' Começa da coluna C
        If ws.Cells(1, c).Value = ano And ws.Cells(2, c).Value = mes Then
            EncontrarColunaFcst = c
            Exit Function
        End If
    Next c
End Function

' =========================================================================================
' FUNÇÃO AUXILIAR - (Exemplo para a rotina de cálculo) Encontra a linha de uma descrição
' =========================================================================================
Private Function FindRow(ByVal ws As Worksheet, ByVal texto As String) As Long
    Dim found As Range
    Set found = ws.Columns("B").Find(What:=texto, LookIn:=xlValues, LookAt:=xlWhole)
    If Not found Is Nothing Then
        FindRow = found.Row
    Else
        FindRow = 0
    End If
End Function